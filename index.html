<!DOCTYPE html>
<html lang="en">
<head>
    <title>CG Project 2019 </title>
    <!-- Meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="Quinten Rosseel">
    <link rel="shortcut icon" href="favicon.ico">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- p5 JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.7.2/p5.js"></script>

    <!-- Javacsript for function visualisation. -->
    <script src= "assets/js/function_vis.js"></script>
    <script src= "assets/js/p5.dom.js"></script>

    <!-- FontAwesome JS -->
    <script defer src="https://use.fontawesome.com/releases/v5.1.1/js/all.js" integrity="sha384-BtvRZcyfv4r0x/phJt9Y9HhnN5ur1Z+kZbKVgzVBAlQZX4jvAuImlIz+bG7TS00a" crossorigin="anonymous"></script>

    <!-- JS for LaTeX formulae -->
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

    <!-- JS for graph visualisation. -->
    <script src='assets/js/mrc.js' async></script>
    <script src='assets/js/cytoscape.js' async></script>
    <script src='assets/js/graph_vis.js' async></script>

    <!-- Global CSS -->
    <link rel="stylesheet" href="assets/plugins/bootstrap/css/bootstrap.min.css">
    <!-- Plugins CSS -->
    <link rel="stylesheet" href="assets/plugins/prism/prism.css">
    <link rel="stylesheet" href="assets/plugins/elegant_font/css/style.css">

    <!-- Theme CSS -->
    <link id="theme-style" rel="stylesheet" href="assets/css/styles.css">

</head>

<body class="body-red">
    <div class="page-wrapper">
        <!-- ******Header****** -->
        <header id="header" class="header">
            <div class="container">
                <div class="branding">
                    <h1 class="logo">
                            <span class="text-bold">Applying Parallel Computation Algorithms in the Design of Serial Algorithms </span>
                    </h1>
                </div><!--//branding-->
                <ol class="breadcrumb">
                    <li class="breadcrumb-item">INFO-F-420 Computational Geometry</li>
                    <li class="breadcrumb-item">Quinten Rosseel</li>
                    <li class="breadcrumb-item">VUB</li>
                    <li class="breadcrumb-item">0536798</li>
                </ol>
            </div><!--//container-->
        </header><!--//header-->
        <div class="doc-wrapper">
            <div class="container">
                <div class="doc-body row">
                    <div class="doc-content col-md-9 col-12 order-1">
                        <div class="content-inner">
                            <section id="abstract" class="doc-section">
                                <h2 class="section-title">Abstract</h2>
                                <div class="section-block">
                                  <p class="text-justify">
                                    This project covers <a href="assets/files/megiddo.pdf" target="_blank">Nimrod Megiddo's paper</a>
                                    <a class="scrollto" href="#ref-1">[1]</a> that presents a generalisation of how parallelism can benefit
                                    the design of serial algorithms in computational problems. In many cases, a good parallel algorithm for one problem
                                    may turn out to be useful for designing an efficient serial algorithm for another problem.
                                    <br>
                                    <br>
                                    We start by (visually) exploring Meggido's preliminary example that demonstrates his general method, known as parametric search.
                                    The technique is frequently used to solve optimization problems in computational geometry.
                                    The method uses a <i>decision algorithm</i>, <i>i.e.</i> an algorithm that checks if a given condition
                                    holds or not, to solve an <i>optimization problem</i>, <i>i.e.</i> an algorithm that determines an optimal solution for a problem.
                                    By cleverly running the decision problem as a concurrent process, Megiddo shows
                                    that parallelism can achieve a lower theoretical bound in some cases.
                                    <br>
                                    <br>
                                    Next, a more advanced setting is explored in the context of the <i>Minimum Ratio Cycle problem </i> (MRC),
                                    where the goal is to find a cycle in a graph with edge-costs and edge-times,
                                    such that the ratio of the total cost to the total time of edges on the cycle is minimized.
                                    This problem was originally coined by <a href="assets/files/dantzig_et_al.pdf" target="_blank">Dantzig et al.</a>
                                    <a class="scrollto" href="#ref-2">[2]</a> in an attempt to solve a ship routing problem.
                                    <br>
                                    <br>
                                    Finally, we present an attempt at an implementation of the parameterization method for the
                                    MRC, inspired on <a href="assets/files/megiddo_earlier.pdf" target="_blank">Megiddo's earlier work</a>
                                    <a class="scrollto" href="#ref-3">[3]</a> and using
                                    <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API" target="_blank">Mozillaâ€™s Web Worker API</a> for
                                    concurrent javascript programming.

                                  </p>
                                </div>
                            </section> <!--//doc-section-->
                            <section id="preliminary" class="doc-section">
                                <h2 class="section-title">Megiddo's Preliminary Example</h2>
                                <div class="section-block">
                                  <p class="text-justify">
                                    <!-- Properly define the function. -->
                                    Let \( \{f_{i}(\lambda), \dots, f_{n}(\lambda) \ | \ i = 1 \dots n \} \)
                                    be a set of pairwise distinct functions of \( \lambda \) such that
                                    \( f_{i}(\lambda) = a_{i} + b_{i}\lambda \ | \ b_{i} > 0 \).
                                    Next, let \( F(\lambda) \) denote the median of the set \( \{f_{i}(\lambda), \dots, f_{n}(\lambda) \} \)
                                    for every \( \lambda \in \mathbb{R} \). Finally, let \( \lambda_{ij} \) denote the intersection of
                                    two distinct functions \( f_{i} \) and \( f_{j} \) in the set \( \{f_{i}(\lambda), \dots, f_{n}(\lambda) \} \),
                                    such that \( a_{i} + b_{i}\lambda_{ij} = a_{j} + b_{j}\lambda_{ij} \) with \( i \neq j\).
                                  </p>
                                  <p class="text-justify">
                                    <b>Function Visualisation</b>
                                    <br> <br>
                                    To showcase how functions from the set \( \{f_{i}(\lambda), \dots, f_{n}(\lambda) \} \) behave, consider
                                    an interactive visualisation of three functions \( f_{1}(\lambda) = a_{1} + b_{1}\lambda, \
                                    f_{2}(\lambda) = a_{2} + b_{2}\lambda \) and
                                    \( \ f_{3}(\lambda) = a_{3} + b_{3}\lambda \ \)
                                    together with their corresponding \( F(\lambda) \) evaluated on \( \{f_{1}(\lambda), f_{2}(\lambda), f_{3}(\lambda) \} \).

                                    Notice that \( b_{i} \) is constrained to be positive
                                    and that the intersections marked in black \( \lambda_{12}, \ \lambda_{13} \) and \( \lambda_{23} \) are critical points for \( F(\lambda) \),
                                    because the evaluation of \( F(\lambda) \) can only change at these points.
                                  </p>
                                    <br><br>

                                    <!-- Function Sliders -->
                                    <div class="container">
                                      <div class="row">
                                          <div class="col-4 text-center">
                                            <label for="a_1_slider_1">\( a_{1} \)</label>
                                            <div class="d-flex justify-content-center my-4">
                                               <span class="font-weight-bold indigo-text mr-2 mt-1">-10</span>
                                                <form class="range-field w-75">
                                                 <input value="12" class="custom-range range-1" type="range" step="1" min="0" max="20" id="a_1_slider_1" />
                                                </form>
                                             <span class="font-weight-bold indigo-text ml-2 mt-1">10</span>
                                           </div>
                                         </div>

                                           <div class="col-4 text-center">
                                             <label for="a_2_slider_1">\( a_{2} \)</label>
                                             <div class="d-flex justify-content-center my-4">
                                                <span class="font-weight-bold indigo-text mr-2 mt-1">-10</span>
                                                   <form class="range-field w-75">
                                                    <input value="20" class="custom-range range-1" type="range" step="1" min="0" max="20" id="a_2_slider_1" />
                                                   </form>
                                               <span class="font-weight-bold indigo-text ml-2 mt-1">10</span>
                                             </div>
                                           </div>

                                           <div class="col-4 text-center">
                                             <label for="a_3_slider_1">\( a_{3} \)</label>
                                             <div class="d-flex justify-content-center my-4 text-center">
                                                <span class="font-weight-bold indigo-text mr-2 mt-1">-10</span>
                                                   <form class="range-field w-75">
                                                    <input value="0" class="custom-range range-1" type="range" step="1" min="0" max="20" id="a_3_slider_1" />
                                                   </form>
                                               <span class="font-weight-bold indigo-text ml-2 mt-1">10</span>
                                             </div>
                                           </div>
                                      </div>
                                        <div class="row">
                                          <div class="col-4 text-center">
                                            <label for="b_1_slider_1">\( b_{1} \)</label>
                                            <div class="d-flex justify-content-center my-4">
                                               <span class="font-weight-bold indigo-text mr-2 mt-1">0</span>
                                                <form class="range-field w-75">
                                                 <input value="0" class="custom-range range-1" type="range" step="1" min="0" max="20" id="b_1_slider_1" />
                                                </form>
                                             <span class="font-weight-bold indigo-text ml-2 mt-1">20</span>
                                           </div>
                                          </div>


                                          <div class="col-4 text-center">
                                            <label for="b_2_slider_1">\( b_{2} \)</label>
                                            <div class="d-flex justify-content-center my-4">
                                               <span class="font-weight-bold indigo-text mr-2 mt-1">0</span>
                                                  <form class="range-field w-75">
                                                   <input value="4" class="custom-range range-1" type="range" step="1" min="0" max="20" id="b_2_slider_1" />
                                                  </form>
                                              <span class="font-weight-bold indigo-text ml-2 mt-1">20</span>
                                            </div>
                                          </div>

                                          <div class="col-4 text-center">
                                            <label for="b_3_slider_1">\( b_{3} \)</label>
                                            <div class="d-flex justify-content-center my-4 text-center">
                                               <span class="font-weight-bold indigo-text mr-2 mt-1">0</span>
                                                  <form class="range-field w-75">
                                                   <input value="9" class="custom-range range-1" type="range" step="1" min="0" max="20" id="b_3_slider_1" />
                                                  </form>
                                              <span class="font-weight-bold indigo-text ml-2 mt-1">20</span>
                                            </div>
                                          </div>
                                      </div>


                                    </div>
                                    <br><br>
                                    <!-- Function Visualisation -->
                                    <div class="container">
                                        <div class="row">
                                            <div class="col-12 text-center" id="func-vis-1">
                                            </div>
                                        </div>
                                      </div>
                                    <br><br>
                                    <p class="text-justify">
                                      It's easy to see now that \( F(\lambda) \) is a piecewise linear function that lies on the line
                                      of the function that evaluates to the median for a particular \( \lambda \). As the \( b_{i} \)'s are positive,
                                      this means that each segment of the function is monotone-increasing.
                                      <br><br>
                                      In piesewise linear functions,
                                      the points where the slope of the function changes are known as breakpoints. Given that we know that a function
                                      of \( n \) lines has
                                      <a href="https://math.stackexchange.com/questions/270937/how-can-you-construct-as-many-intersections-as-possible-with-n-lines"
                                      target="_blank">
                                        at most \( \frac{n^{2} - n }{2} \) intersections</a>, the upper bound for breakpoints is \( O(n^{2}) \).
                                      It is straightforward to see now that if we are given \( \lambda \), we can evaluate \( F(\lambda) \)
                                      using a <a href="assets/files/dantzig_et_al.pdf" target="_blank">linear-time selection algorithm </a> <a class="scrollto" href="#ref-4">[4]</a> such that
                                      \( F(\lambda) \) can be evaluated with \( O(n) \) comparisons.
                                      <br><br>
                                      <b>A first serial attempt</b>
                                      <br><br>
                                      If we were to try to find a \( \lambda \) such that
                                      \( F(\lambda) = 0 \), the visualisation above might suggest one possible way to do that:
                                      <br><br>
                                      <ul class="text-justify">
                                        <li>Identify the intersection points \( \lambda_{ij} \) where \( a_{i} + b_{i}\lambda_{ij} = a_{j} + b_{j}\lambda_{ij}\)
                                            and \( i \neq j \). We know that every breakpoint of \( F \) is equal to one of the \( \lambda_{ij}\)'s.
                                        </li>
                                        <li>Search the set of identified \( \lambda_{ij} \)'s for two values \( \lambda^{1} \) and \( \lambda^{2} \), such that
                                          there are no other \( \lambda_{ij} \)'s in the open interval \( (\lambda^{1}, 0) \cup (0, \lambda^{2}) \).

                                        </li>
                                      </ul>
                                      <br>
                                    </p>
                                    <p class="text-justify">
                                      As \( F(\lambda) \) is linear over the interval \([\lambda^{1},  \lambda^{2}]\), the intersection with the origin
                                      can be found in \( O(1) \) once \( \lambda^{1} \) and \( \lambda^{2} \) are known. Because our function is monotone-increasing,
                                      the search for such an interval can be found with a binary search that requires \( O(log(n)) \ F\) evaluations in which the
                                      cardinalities of the searched sets are \( n, \frac{n}{2}, \frac{n}{4}, \dots \ \). The total running time of this algorithm
                                      is \( O(n^{2} + n \ log(n)) \) = \( O(n^{2})\),
                                      where the dominating factor is the evaluation of all the intersection points \( \lambda_{ij} \),

                                      <br><br>
                                      <b>A second serial attempt</b>
                                      <br><br>
                                      An <a href="assets/files/megiddo_earlier" target="_blank">alternative approach</a> suggested by Megiddo
                                      <a class="scrollto" href="#ref-3">[3]</a> yields the same serial running time of \( O(n^{2}) \)
                                      but is shown to benefit from parallel computation.
                                      Remember that we are looking for for two values \( \lambda^{1} \) and \( \lambda^{2} \), such that
                                      there are no other \( \lambda_{ij} \)'s in the open interval \( (\lambda^{1}, 0) \cup (0, \lambda^{2}) \).
                                      With this interval, we can solve for the origin in a single step.
                                      <br><br>
                                      Let \( \lambda^{*} \) be the unknown solution to \( F(\lambda^{*}) = 0 \). In order to evaluate \( F \) by
                                      a linear-time median algorithm, the value of \( \lambda \) needs to be known to compare each
                                      \( f_{i}(\lambda) \) and \( f_{j}(\lambda) \) in the set \( \{f_{i}(\lambda), \dots, f_{n}(\lambda) \} \). Nevertheless,
                                      we know that only intersection points \( \lambda_{ij} \ | \ i \neq j \)
                                      really matter for the comparison of the median algorithm (they are critical values): if \( \lambda \geq \lambda_{ij} \), then we know that
                                      \( f_{i} (\lambda) \geq f_{j}(\lambda) \) whereas for \( \lambda \leq \lambda_{ij} \) we know that
                                      \( f_{i} (\lambda) \leq f_{j}(\lambda) \), or vice versa.
                                      <br><br>
                                      So when we consider two functions \( f_{i} (\lambda) \) and \( f_{j} (\lambda) \), all we really need is the intersection
                                      point \( \lambda_{ij} \) to compare \( F(\lambda_{ij}) \) and \(0\) to solve for \( F(\lambda^{*}) = 0 \). As each
                                      function is monotone increasing, we know that if the sign
                                      of \( F(\lambda_{ij}) \) is negative, then \( \lambda^{*} \geq \lambda_{ij} \) and if the sign
                                      is positive, then \( \lambda^{*} \leq \lambda_{ij} \).
                                      <br><br>
                                      The remark above suggests a parallel algorithm, as each intersection point \( \lambda_{ij} \) of two
                                      functions in the set \( \{f_{i}(\lambda), \dots, f_{n}(\lambda) \} \) can be computed and compared independently
                                      with a shared variable that keeps track of the smallest interval bounds so far. If an intersection point \( \lambda_{ij} \) lies between the
                                      current bounds \( [\lambda_{min}, \lambda_{max}]\) then we can update that interval to be either
                                      \( [\lambda_{ij}, \lambda_{max}]\) or \( [\lambda_{min}, \lambda_{ij}]\) depending on the sign of \( F(\lambda_{ij}) \).
                                      If an intersection point \( \lambda_{ij} \) lies outside the
                                     current bounds \( [\lambda_{min}, \lambda_{max}]\) then the result of the comparison is uniform over the interval
                                     and the interval can remain as is.
                                     <br><br>
                                     In serial time, the total running time remains \( O(n^{2}) \) as we have to gather all intersections
                                     of the set \( \{f_{i}(\lambda), \dots, f_{n}(\lambda) \} \) in \( O(n^{2}) \) and
                                     compare the resulting critical points in \( O(n) \) that each may require a \( O(n) \)
                                     median finding to evaluate \( F \), leaving us with \( O(n^{2} + n^{2}) = O(n^{2}) \).
                                     Let's see if we can do better with parallelism.
                                     <br><br>
                                     <b>Speeding Up with Parallelism</b>
                                     <br><br>
                                     Before making any claims about the parallel running time, it's important to note that Megiddo does not
                                     account for overhead resulting from memory conflicts, memory syncronization or deadlocks that are typically
                                     associated with parallelism. Rather, Megiddo simulates parallelism serially by running each independent process after one another.
                                     This reduces the complexity (and arguably running time) of his results.
                                     <br><br>
                                     <img src="assets/images/simulation.svg" width="100%" height="auto">
                                     <br><br>
                                     Let \( P \) denote the number of processors and let \( T(n, P) \) denote the number of comparison steps
                                     for sorting \( n \) values on a machine with \( P \) processors.
                                     <br><br>
                                     As already mentioned, the intersection \( \lambda_{ij} \) of two functions \( f_{i} \) and \( f_{j} \)
                                     from the set \( \{f_{i}(\lambda), \dots, f_{n}(\lambda) \} \) can be computed in \( O(1) \) such that one step in the simulated
                                     multiprocessor yields \( P \) critical values. As suggested in the explanation of the previous algorithm, these comparisons can
                                     happen independently of each other.
                                     <br><br>
                                     Without loss of generality, we can say that there exists a labeling such that the critical values
                                     resulting from a multiprocessor step can be written as \( \lambda_{1} \leq \lambda_{2} \leq \dots \leq \lambda_{P}.\)
                                     Megiddo does not assume that these values are sorted in his running time analysis, but with a parallel sorting algorithm
                                     like Valiant's <a class="scrollto" href="#ref-5">[5]</a> or Preparata's <a class="scrollto" href="#ref-6">[6]</a>, a
                                     sorting time of \( T(n, P) = O(log(n)) \) or \( T(n, P) = O(log(n)log(log(n)) \) can be achieved when \( P = n \) and \( P = log(n) \) respectively.
                                     <br><br>
                                     With the set of \( P \) critical values sorted, an interval \( [\lambda_{i}, \lambda_{i+1}] \ | \ i \in [0, P] \) can be identified with
                                     a \( O(log(P)) \) binary search, using a linear-time median algorithm to pivot,
                                     such that \( \lambda_{i} \leq \lambda^{*} \leq \lambda_{i+1} \). In each step, we take an intersection between the found interval and the
                                     interval of the previous step to get the smallest possible interval that satisfies \( \lambda_{i} \leq \lambda^{*} \leq \lambda_{i+1} \).
                                     This repeats \( T(n, P) \) times until an interval is found that does not intersect with the previous interval
                                     and the median function \( F \) crosses the zero level over the interval. Here, the equation can be solved in  \( O(1) \).
                                     <br><br>
                                     The running time of the algorithm presented above yields \( O(nlog(n)^{2}) \) for Preparata's scheme and
                                     \( O(nlog(n)^{2}log(log(n))) \) for Valiant's. Both bounds being superior to the previous \( O(n^{2}) \).

                                    </p>

                                    <p class="text-justify">
                                      <!--
                                      <b>Function Visualisation 2</b>
                                      <br> <br>
                                      In the example below \( F(\lambda) \) is shown with all \( a_{i} \)'s, uniformly drawn from
                                      an interval \( [a_{min}, a_{max}] \) and all \( b_{i} \)'s, uniformly drawn from
                                      an interval \( [b_{min}, b_{max}] \) with \( b_{min}, b_{max} > 0 \). The last slider for \( n \) determines the number of functions in the set
                                      \( \{f_{i}(\lambda), \dots, f_{n}(\lambda) \} \).

                                      -->
                                      <!-- Function Sliders -->
                                      <!-- <div class="container">
                                        <div class="row">
                                          <div class="col-3 text-center">
                                            <label for="a_1_slider_2">\( a_{min} \)</label>
                                              <div class="d-flex justify-content-center my-4">
                                                 <span class="font-weight-bold indigo-text mr-2 mt-1">-10</span>
                                                  <form class="range-field w-75">
                                                   <input class="custom-range range-2" type="range" step="1" min="0" max="10" id="a_1_slider_2" />
                                                  </form>
                                               <span class="font-weight-bold indigo-text ml-2 mt-1">0</span>
                                             </div>
                                          </div>
                                           <div class="col-3 text-center">
                                             <label for="a_2_slider_2">\( a_{max} \)</label>
                                             <div class="d-flex justify-content-center my-4">
                                                <span class="font-weight-bold indigo-text mr-2 mt-1">0</span>
                                                   <form class="range-field w-75">
                                                    <input class="custom-range range-2" type="range" step="1" min="10" max="20" id="a_2_slider_2" />
                                                   </form>
                                               <span class="font-weight-bold indigo-text ml-2 mt-1">10</span>
                                             </div>
                                           </div>
                                          <div class="col-3 text-center">
                                            <label for="b_1_slider_2">\( b_{min} \)</label>
                                            <div class="d-flex justify-content-center my-4">
                                               <span class="font-weight-bold indigo-text mr-2 mt-1">0</span>
                                                <form class="range-field w-75">
                                                 <input class="custom-range range-2" type="range" step="1" min="0" max="10" id="b_1_slider_2" />
                                                </form>
                                             <span class="font-weight-bold indigo-text ml-2 mt-1">10</span>
                                           </div>
                                          </div>

                                          <div class="col-3 text-center">
                                            <label for="b_2_slider_2">\( b_{max} \)</label>
                                            <div class="d-flex justify-content-center my-4">
                                               <span class="font-weight-bold indigo-text mr-2 mt-1">10</span>
                                                  <form class="range-field w-75">
                                                   <input class="custom-range range-2" type="range" step="1" min="10" max="20" id="b_2_slider_2" />
                                                  </form>
                                              <span class="font-weight-bold indigo-text ml-2 mt-1">20</span>
                                            </div>
                                          </div>
                                        </div>
                                        <div class="row">
                                          <div class="col-12">
                                            <div class="col-3 mx-auto text-center">
                                              <label for="n_slider_2">\( n \)</label>
                                              <div class="d-flex justify-content-center my-4 text-center">
                                                 <span class="font-weight-bold indigo-text mr-2 mt-1">0</span>
                                                    <form class="range-field w-75">
                                                     <input class="custom-range range-2" type="range" step="1" min="0" max="10" id="n_slider_2" />
                                                    </form>
                                                <span class="font-weight-bold indigo-text ml-2 mt-1">10</span>
                                              </div>
                                            </div>
                                          </div>
                                        </div>
                                      </div> -->
                                      <!-- Function Visualisation -->
                                      <!-- <div class="container">
                                          <div class="row">
                                              <div class="col-12 text-center" id="func-vis-2">
                                              </div>
                                          </div>
                                        </div> -->
                                      <!-- <ul>
                                        <li> Each \( a, b \) are drawn uniformly in an interval. This interval can be adapted using sliders. </li>
                                        <li> \( n\) can be chosen. </li>
                                        <li> Reset button for new draw. </li>
                                      </ul> -->
                                    </p>
                                  <!--

                                  <p>
                                      \( \{f_{1}(\lambda), f_{2}(\lambda), ..., f_{n}(\lambda) \} \) -->
                                    <!-- Understand how Megiddo maps from a parallel to a serial problem.

                                    <i>e.g.</i> an algorithm that checks if a given parameter \( \lambda \leq 0 \)
                                   or \( \lambda \geq 0 \), to solve an <i>optimization problem</i>, <i>e.g.</i> a search algorithm that determines a \( \lambda \) such that
                                   \( F(\lambda) = 0 \) for a given function \( F \).
                                 </p>
                                -->
                              </div>


                            </section><!--//doc-section-->
                            <section id="mrc" class="doc-section">
                                <h2 class="section-title">Minimum Ratio Cycle problem (MRC)</h2>
                                <div class="section-block">
                                  <p class="text-justify">
                                      The MRC problem was coined by <a href="assets/files/dantzig_et_al.pdf" target="_blank">Dantzig et al.</a>
                                      <a class="scrollto" href="#ref-2">[2]</a> in the context of a ship routing problem posed by the
                                      American Office of Naval Research. Practically, the problem concerns a ship owner that wants to <i>maximize</i> his total profit
                                      over time while making a round trip through multiple ports. Dantzig et al. show that finding a cycle with <i>minimal</i> total edge-cost
                                      over edge-time in a directed graph is a subproblem to solve the maximization problem.
                                      <br><br>
                                      <b> Representation </b>
                                      <br><br>
                                      More abstractly, each vertex \( i \) within a directed graph \( \mathcal{G} = (V, E)\),
                                      with \(V\) a set of vertices and \(E\) a set of edges,
                                      has an associated cost \( c_{ij} \) and travel time \( t_{ij} \) to reach a vertex \( j \).
                                      Self-loops are not allowed in \( \mathcal{G} \).
                                      <br><br>
                                      The problem can be represented as an adjacency matrix \( A \in \{0, 1\}^{|V| \times |V|} \) determining the directed graph, a
                                      cost matrix \( C \in \mathbb{R}^{|V| \times |V|} \) and a time matrix \( T \in \mathbb{R}^{|V| \times |V|} \).
                                      If there is a directed edge from vertex \( i \) to \( j \), then \( A_{ij} = 1 \), if not then \( A_{ij} = 0 \).
                                      As there are no self-loops in \( \mathcal{G} \), the diagonal elements of the matrix are always \( 0 \).
                                      An interactive example of the setup is given below.
                                      <br><br>
                                      $$ A =
                                      \begin{bmatrix}
                                        0 & 1 & 0 & 0 & 0 \\
                                        1 & 0 & 1 & 0 & 1 \\
                                        0 & 0 & 0 & 1 & 0 \\
                                        1 & 0 & 1 & 0 & 0 \\
                                        1 & 1 & 0 & 0 & 0 \\
                                      \end{bmatrix}\
                                      C =
                                      \begin{bmatrix}
                                        0 & 8 & 0 & 0 & 0 \\
                                        3 & 0 & 9 & 0 & 4 \\
                                        0 & 0 & 0 & 7 & 0 \\
                                        2 & 0 & 1 & 0 & 0 \\
                                        6 & 11 & 0 & 0 & 0 \\
                                      \end{bmatrix}\
                                      T =
                                      \begin{bmatrix}
                                        0 & 3 & 0 & 0 & 0 \\
                                        1 & 0 & 4 & 0 & 1 \\
                                        0 & 0 & 0 & 2 & 0 \\
                                        3 & 0 & 1 & 0 & 0 \\
                                        2 & 9 & 0 & 0 & 0 \\
                                      \end{bmatrix}\

                                      $$
                                  </p>
                                </div>
                                <div id="graph-vis-1" class="full-width height-500">
                                </div>

                                <p class="text-justify">
                                  <!--The first step is to define -->
                                  <b> Megiddo's Theorem </b>
                                  <br><br>
                                  To continue, we need to get this problem in a formulation that expresses the minimization.
                                  Numerous combinatoral optimization problems can be formulated as linear minimization problems
                                  subject to certain constraints. Megiddo highlights two classes of problems <a class="scrollto" href="#ref-3">[3]</a>
                                  and proves an important relationship between them.
                                  <br><br>
                                  $$ \textbf{Problem A. } \ \text{Minimize } \ c_{1}x_{1} + \dots + c_{n}x_{n} \
                                  \text{ subject to } \ x = (x_{1}, \dots, x_{n}) \in D $$
                                  $$ \textbf{Problem B. } \ \text{Minimize } \
                                  \frac{a_{0} + a_{1}x_{1} + \dots + a_{n}x_{n}}{b_{0} + b_{1}x_{1} + \dots + b_{n}x_{n}} \
                                  \text{ subject to } \ x = (x_{1}, \dots, x_{n}) \in D $$

                                  $$\text{With } \ D \ \text{ a set of conditions or constraints to which } \ x = (x_{1}, \dots, x_{n}) \\
                                  \text{ must adhere in order to be a valid solution.} $$
                                  <br><br>
                                  Examples satisfying the definition of problem \( A \) are the shortest (simple) path, the
                                  traveling salesman, the Chinese postman, the minimum spanning tree and various other scheduling problems.
                                  Problem \( B \) is a generalization of problem \( A \) that also includes MRC as a valid problem instance.
                                  <br><br>
                                    Before getting to any concrete algorithm for MRC, it is beneficial to look at a more general setting.
                                    The goal is to relate problem \( A \) with problem \( B \), such that we can use algorithms for problem \( A \) to solve
                                    problem instances of problem \( B \). Megiddo's main result goes as follows.
                                    <br><br>
                                    \(\textbf{Theorem. } \) If problem \(A\) is solvable within \(O(p(n))\) comparisons and \( O(q(n)) \)
                                    additions, then problem \( B \) is solvable in time \( O(p(n)(q(n) + p(n)))\).
                                    <br><br>
                                    Megiddo starts by showcasing a standard trick to solve ratio minimization problems. Given a problem
                                    \(B \) with values for the coefficients, pick a fixed number \(t \in \mathbb{R} \) and solve problem \(A \) for
                                    \( \{ c_{i}(t) = a_{i} - tb_{i} \ | \ i = 1, \dots, n \} \) under the same constraints \(D \).
                                    <br><br>
                                    Now suppose that \( v \) is an optimal value of problem \( A \) such that \( v = \min \big( (a_{1} - tb_{1})x_{1} + \dots + (a_{n} - tb_{n})x_{n} \big) \) with \( x \in D \).
                                    If \( v \) can be written as \( v= tb_{0} - a_{0}\), then \( t \) must be the optimal value for problem \( B \), such that
                                    \( t = \min \big( \frac{a_{0}}{b_{0}} + \frac{a_{1}}{b_{1}}x_{1} + \dots + \frac{a_{n}}{b_{n}}x_{n} \big) \), where each
                                    \( \frac{a_{i}}{b_{i}}\) corresponds with a root of \( c_{i}(t) = a_{i} - tb_{i} \) such that \( c_{i}(\frac{a_{i}}{b_{i}}) = 0 \).
                                    On the other hand, the solution \( x = (x_{1}, \dots, x_{n}) \in D \) of problem \( A \) is optimal with respect to \( t \)
                                    because of the assumptions.
                                    <br><br>
                                    <!-- Note that \frac{a_{0}}{b_{0}} is a constant for the minimization! -->
                                    In the case that \( v < tb_{0} - a_{0}\), a smaller \(t\) should be tested and if \( v > tb_{0} - a_{0}\),
                                    a bigger \(t\) should be tested. Essentially, Megiddo proofs his theorem by parameterizing problem \( A \)
                                    with a linear function \( c_{i}(t) \) for which the optimal \( t^{*} \) needs to be found. Finding \( t^{*} \) is done
                                    by comparing each minimum value \(v(t) = \min \big( (a_{1} - tb_{1})x_{1} + \dots + (a_{n} - tb_{n})x_{n} \big) \) of problem \(A\) and gradually adjusting the interval \([e, f]\) that contains \( t^{*} \).
                                    This parameterization and convergence to an interval in allow Megiddo to relate problem \( A \) with problem \( B \) and derive his theorem.
                                    <br><br>
                                    <b> Solution of MRC &amp; Implementation</b>
                                    <br><br>
                                    We are now ready to understand a practical example that uses this result to find a minimum ratio cycle.
                                    We can see that a matrix \( X \in \{0, 1\}^{|V| \times |V|} \) could encode the valid paths that
                                    are available to take, to determine what cost-time ratios are accounted for. Megiddo suggests that
                                    \( D \) in this case is the set of all possible zero-one matrices \( X \) that encode a simple directed cycle.
                                    An example of an \( X \in D \) based on the problem defined by adjacency matrix \( A \) is given below.
                                    The numerator and denominator of problem \( B \) correspond with the previously discussed \( C \) and \( T \) matrix
                                    respectively.
                                    <br><br>
                                    $$ A =
                                    \begin{bmatrix}
                                      0 & 1 & 0 & 0 & 0 \\
                                      1 & 0 & 1 & 0 & 1 \\
                                      0 & 0 & 0 & 1 & 0 \\
                                      1 & 0 & 1 & 0 & 0 \\
                                      1 & 1 & 0 & 0 & 0 \\
                                    \end{bmatrix}
                                    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \
                                    X =
                                    \begin{bmatrix}
                                      0 & 1 & 0 & 0 & 0 \\
                                      0 & 0 & 1 & 0 & 0 \\
                                      0 & 0 & 0 & 1 & 0 \\
                                      1 & 0 & 0 & 0 & 0 \\
                                      0 & 0 & 0 & 0 & 0 \\
                                    \end{bmatrix}
                                    $$
                                    </p>
                                    <div class="row">
                                      <div class="col-6">
                                        <div id="graph-vis-3" class="full-width height-500">
                                        </div>
                                      </div>
                                      <div class="col-6">
                                        <div id="graph-vis-2" class="full-width height-500">
                                        </div>
                                      </div>
                                    </div>

                                    <p class="text-justify">
                                      The first step for an MRC-algorithm is to have a negative cycle detector. Megiddo uses
                                      the Floyd-Warshall algorithm (FW) as a negative cycle detector by checking the resulting all-shortest-pairs matrix
                                      for negative values. More background on using FW as a negative cycles detector can be found in
                                      <a href="assets/files/floyd_warshall.pdf" target="_blank"> Hougard's paper </a>
                                      <a class="scrollto" href="#ref-7">[7]</a>. Before we can apply Floyd-Warshall however,
                                      we need to encode the cost-time ratios in our adjacency matrix like below. Aditionally,
                                      we encode the absence of a path between two different nodes with \( \infty \).

                                      <br><br>
                                      $$ X^{'} =
                                      \begin{bmatrix}
                                        0 & \frac{C_{0, 1}}{T_{0, 1}} & \infty & \infty & \infty \\
                                        \frac{C_{1, 0}}{T_{1, 0}} & 0 & \frac{C_{1, 2}}{T_{1, 2}} & \infty & \frac{C_{1, 4}}{T_{1, 4}} \\
                                        \infty & \infty & 0 & \frac{C_{2, 3}}{T_{2, 3}} & \infty \\
                                        \frac{C_{3, 0}}{T_{3, 0}} & \infty & \frac{C_{3, 2}}{T_{3, 2}} & 0 & 0 \\
                                        \frac{C_{4, 0}}{T_{4, 0}} & \frac{C_{4, 1}}{T_{4, 1}} & \infty & \infty & 0 \\
                                      \end{bmatrix}\
                                      =
                                      \begin{bmatrix}
                                        0 & \frac{\Large 8}{\Large 3} & \infty & \infty & \infty \\
                                        \frac{\Large 3}{\Large 1} & 0 & \frac{\Large 9}{\Large 4} & \infty & \frac{\Large 4}{\Large 1} \\
                                        \infty & \infty & 0 & \frac{\Large 7}{\Large 2} & \infty \\
                                        \frac{\Large 2}{\Large 3} & 0 & \frac{\Large 1}{\Large 1} & 0 & \infty \\
                                        \frac{\Large 6}{\Large 2} & \frac{\Large 11}{\Large 9} & \infty & \infty & 0 \\
                                      \end{bmatrix}
                                      $$
                                      </p>

                                      <div class="section-block javascript">
                                          <div class="code-block">
                                              <h6>Floyd-Warshall Algorithm </h6>
                                              The basic idea of the Floyd-Warshall algorithm comes from the observation that
                                              an edge \( e_{ij} \) is the shortest path from vertex \(i\) to \(j\) if and only if there is no other route
                                              \( \{e_{ik},e_{kj} \} \) such that
                                              \( \delta(e_{ij}) > \delta(e_{ik}) + \delta(e_{jk}) \) with \(\delta(x) \) a
                                              distance function of choice. The basic idea is demonstrated below. The input of the algorithm
                                              \( m \) corresponds with the matrix \( X^{'} \) from above.
                                              <br><br>
                                              FW can be used as a negative cycles detector by running it again, and checking if the values
                                              remain the same for each element in the matrix. If they do not, then there is a negative cycle in the graph,
                                              otherwise, there are no negative cycles.

                                              <pre><code class="language-javascript">
      function basic_floyd_warshall(m) {
        for(var k = 0; k < n; k++) {
          for(var i = 0; i < n; i++) {
            for(var j = 0; j < n; j++) {
              if(m[i][k] + m[k][j] < m[i][j]) {
                m[i][j] = m[i][k] + m[k][j]; // Detour is shorter
              }
            }
          }
        }
      }
                                          </code></pre>
                                          </div><!--//code-block-->

                                          <p class="text-justify"> (Insert algorithm solution here!) </p>
                                      </div><!--//section-block-->



                            </section> <!--//doc-section-->
                            <section id="references" class="doc-section">
                                <h2 class="section-title">References</h2>
                                <div class="section-block">
                                  <div class="container" id="ref-1">
                                    <div class="row">
                                      <div class="col-1">
                                        <p>[1]</p>
                                      </div>
                                      <div class="col-11">
                                        <p class="text-justify">
                                          Megiddo, N. (1981, October). Applying parallel computation algorithms in the design of serial algorithms.
                                          In 22nd Annual Symposium on Foundations of Computer Science (sfcs 1981) (pp. 399-408). IEEE.
                                        </p>
                                      </div>
                                    </div>
                                  </div>
                                  <div class="container" id="ref-2">
                                    <div class="row">
                                      <div class="col-1">
                                        <p>[2]</p>
                                      </div>
                                      <div class="col-11">
                                        <p class="text-justify">
                                          Dantzig, G. B., Blattner, W. and Rao, M. R. (1967). Finding a Cycle in a Graph
                                          with Minimum Cost to Time Ratio with Application to a Ship Routing Problem.
                                          In Theory of Graphs, P. Rosenstiehl, ed. Dunod, Paris, and Gordon and
                                          Breach, New York. 77-84.
                                        </p>
                                      </div>
                                    </div>
                                  </div>

                                  <div class="container" id="ref-3">
                                    <div class="row">
                                      <div class="col-1">
                                        <p>[3]</p>
                                      </div>
                                      <div class="col-11">
                                        <p class="text-justify">
                                            Megiddo, N. (1978, May).
                                            Combinatorial optimization with rational objective functions.
                                            In Proceedings of the tenth annual ACM symposium on Theory of computing (pp. 1-12). ACM.
                                        </p>
                                      </div>
                                    </div>
                                  </div>

                                  <div class="container" id="ref-4">
                                    <div class="row">
                                      <div class="col-1">
                                        <p>[4]</p>
                                      </div>
                                      <div class="col-11">
                                        <p class="text-justify">
                                          Blum, M., Floyd, R. W., Pratt, V. R., Rivest, R. L., & Tarjan, R. E. (1973).
                                          Time bounds for selection. J. Comput. Syst. Sci., 7(4), 448-461.
                                        </p>
                                      </div>
                                    </div>
                                  </div>

                                  <div class="container" id="ref-5">
                                    <div class="row">
                                      <div class="col-1">
                                        <p>[5]</p>
                                      </div>
                                      <div class="col-11">
                                        <p class="text-justify">
                                          Valiant, L.G. Parallelism in comparison problems SIAM J. Comput 4 (1975), 348-355.
                                        </p>
                                      </div>
                                    </div>
                                  </div>

                                  <div class="container" id="ref-6">
                                    <div class="row">
                                      <div class="col-1">
                                        <p>[6]</p>
                                      </div>
                                      <div class="col-11">
                                        <p class="text-justify">
                                        Preparata, F.P. New parallel-sorting schemes. IEEE Trans Comput. C-27 (1978), 669-673.
                                        </p>
                                      </div>
                                    </div>
                                  </div>

                                  <div class="container" id="ref-7">
                                    <div class="row">
                                      <div class="col-1">
                                        <p>[7]</p>
                                      </div>
                                      <div class="col-11">
                                        <p class="text-justify">
                                        Hougardy, Stefan. (2010). The Floyd-Warshall algorithm on graphs with negative cycles. Inf. Process. Lett.. 110. 279-281. 10.1016/j.ipl.2010.02.001.
                                        </p>
                                      </div>
                                    </div>
                                  </div>
                                </div>
                            </section><!--//doc-section-->
                        </div><!--//content-inner-->
                    </div><!--//doc-content-->
                    <div class="doc-sidebar col-md-3 col-12 order-0 d-none d-md-flex">
                        <div id="doc-nav" class="doc-nav">
	                            <nav id="doc-menu" class="nav doc-menu flex-column sticky">
	                                <a class="nav-link scrollto" href="#abstract">Abstract</a>
                                  <a class="nav-link scrollto" href="#preliminary">Megiddo's Preliminary Example</a>
                                  <a class="nav-link scrollto" href="#mrc">Minimum Ratio Cycle (MRC)</a>
                                  <a class="nav-link scrollto" href="#references">References</a>
                                <!--
	                                <a class="nav-link scrollto" href="#installation-section">Head</a>
                                    <nav class="doc-sub-menu nav flex-column">
                                        <a class="nav-link scrollto" href="#step1">Step One</a>
                                        <a class="nav-link scrollto" href="#step2">Step Two</a>
                                        <a class="nav-link scrollto" href="#step3">Step Three</a>
                                    </nav>
	                                <a class="nav-link scrollto" href="#code-section">Code</a>
                                    <nav class="doc-sub-menu nav flex-column">
                                        <a class="nav-link scrollto" href="#javascript">JavaScript</a>
                                    </nav>
	                                <a class="nav-link scrollto" href="#callouts-section">Callouts</a>
	                                <a class="nav-link scrollto" href="#tables-section">Tables</a>
	                                <a class="nav-link scrollto" href="#buttons-section">Buttons</a>
	                                <a class="nav-link scrollto" href="#video-section">Video</a>
	                                <a class="nav-link scrollto" href="#icons-section">Icons</a>
                                -->
	                            </nav><!--//doc-menu-->
                        </div>
                    </div><!--//doc-sidebar-->

                </div><!--//doc-body-->
            </div><!--//container-->
        </div><!--//doc-wrapper-->
    </div><!--//page-wrapper-->

    <footer id="footer" class="footer text-center">
        <div class="container">
            <!--/* This template is released under the Creative Commons Attribution 3.0 License. Please keep the attribution link below when using for your own project. Thank you for your support. :) If you'd like to use the template without the attribution, you can buy the commercial license via our website: themes.3rdwavemedia.com */-->
            <small class="copyright">Thanks to <a href="https://themes.3rdwavemedia.com/" target="_blank">Xiaoying Riley</a> for the theme.</small>

        </div><!--//container-->
    </footer><!--//footer-->


    <!-- Main Javascript -->
    <script type="text/javascript" src="assets/plugins/jquery-3.3.1.min.js"></script>
    <script type="text/javascript" src="assets/plugins/bootstrap/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="assets/plugins/prism/prism.js"></script>
    <script type="text/javascript" src="assets/plugins/jquery-scrollTo/jquery.scrollTo.min.js"></script>
    <script type="text/javascript" src="assets/plugins/stickyfill/dist/stickyfill.min.js"></script>
    <script type="text/javascript" src="assets/js/main.js"></script>

</body>
</html>
